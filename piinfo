#!/usr/bin/env lua

local function printf(...) print(string.format(...)) end

local writer_mt = {
    __index = function(t, k)
        return ({
            printf = function(self, ...)
                local prefix = self.prefix or ""
                return table.insert(self, prefix .. string.format(...))
            end
        })[k]
    end
}

local function read(path)
    return assert(io.open(path, "r"), "can't open file: " .. path)
end

local function system(command)
    return assert(io.popen(command, 'r'), "can't execute command: " .. command)
end

local function walk(iter)
    local t = {}
    for v in iter do table.insert(t, v) end
    return t
end

local function loadavg(w)
    local f = read("/proc/loadavg")
    local line = f:read()
    f:close()
    local s = table.concat(walk(string.gmatch(line, "[%d.]+")), " ", 1, 3)
    w:printf("%-20s  %s", "System load:", s)
end

local function temp(w)
    local f = read("/sys/devices/virtual/thermal/thermal_zone0/temp")
    local raw = tonumber(f:read())
    local celsius = raw * 1e-3
    w:printf("%-20s  %.01f C", "Temperature:", celsius)
end

local iec_units = {"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"}
local function format_iec(format, x)
    local n, max
    if x > 1 then
        n = math.floor((math.floor(math.log(x) / math.log(2)) - 3) / 10)
    else
        n = 0
    end
    if n < 0 then n = 0 end
    max = #iec_units - 1
    if n > max then n = max end
    return string.format(format, x / math.pow(2.0, n * 10.0), iec_units[n + 1])
end

local function meminfo(w)
    local pat = "^([^:]+):%s*(%d+) kB$"
    local f = read("/proc/meminfo")
    local t = {}
    for line in f:lines() do
        local k, v = string.match(line, pat)
        if k and v then t[k] = tonumber(v) end
    end
    f:close()

    local mem_total_kb = t["MemTotal"]
    local mem_available_kb = t["MemAvailable"]
    local swap_total_kb = t["SwapTotal"]
    local swap_free_kb = t["SwapFree"]
    local commit_limit_kb = t["CommitLimit"]
    local commit_kb = t["Committed_AS"]
    local dirty_kb = t["Dirty"]
    local writeback_kb = t["Writeback"]

    local mem_used_kb = mem_total_kb - mem_available_kb
    local swap_used_kb = swap_total_kb - swap_free_kb
    local usage = mem_used_kb / mem_total_kb
    local dirty_ratio = (dirty_kb + writeback_kb) / mem_available_kb
    local swap_usage
    if swap_total_kb > 0 then swap_usage = swap_used_kb / swap_total_kb end
    local commit_charge = commit_kb / mem_total_kb
    local commit_usage = commit_kb / commit_limit_kb

    w:printf("%-20s  %s / %s (%.0f%%)", "Memory usage:",
             format_iec("%.0f %s", mem_used_kb * 1024.0),
             format_iec("%.0f %s", mem_total_kb * 1024.0), usage * 1e+2)
    w:printf("%-20s  %s + %s (%.0f%%)", "Memory dirty:",
             format_iec("%.0f %s", dirty_kb * 1024.0),
             format_iec("%.0f %s", writeback_kb * 1024.0), dirty_ratio * 1e+2)
    if swap_usage then
        w:printf("%-20s  %s / %s (%.0f%%)", "Swap usage:",
                 format_iec("%.0f %s", swap_used_kb * 1024.0),
                 format_iec("%.0f %s", swap_total_kb * 1024.0),
                 swap_usage * 1e+2)
    end
    w:printf("%-20s  %s < %s (%.0f%%, %.0f%%)", "Commit charge:",
             format_iec("%.0f %s", commit_kb * 1024.0),
             format_iec("%.0f %s", commit_limit_kb * 1024.0),
             commit_charge * 1e+2, commit_usage * 1e+2)
end

local function fsusage(w, mount)
    local pat = "%s+(%d+)"
    local f = system(string.format("df -P \"%s\"", mount))
    local lines = walk(f:lines())
    f:close()
    if not lines[2] then return end
    local pat = "^[^%s]+%s+(%d+)%s+(%d+)%s+(%d+)"
    local total, used, available = string.match(lines[2], pat)
    if not (total and used and available) then return end
    local usage = used / total
    if usage < 0.9 then
        usage = string.format("%.1f%%", usage * 1e+2)
    else
        usage = string.format("%.1f%% !", usage * 1e+2)
    end
    w:printf("%-20s  %s / %s (%s)", string.format("Usage of %s:", mount),
             format_iec("%.2f %s", used * 1024.0),
             format_iec("%.2f %s", total * 1024.0), usage)
end

local function uptime(w, now)
    local pat = "^btime%s+(%d+)"
    local f = read("/proc/stat")
    local btime
    for line in f:lines() do
        local m = string.match(line, pat)
        if m then
            btime = tonumber(m)
            break
        end
    end
    f:close()
    if not btime then return end
    local uptime = now - btime
    local days = math.floor(uptime / (24 * 60 * 60))
    uptime = uptime % (24 * 60 * 60)
    local hours = math.floor(uptime / (60 * 60))
    uptime = uptime % (60 * 60)
    local minutes = math.floor(uptime / 60)
    uptime = uptime % 60
    local seconds = uptime
    w:printf("%-20s  %d days, %02d:%02d:%02d", "Uptime:", days, hours, minutes,
             seconds)
end

local function motd()
    local now = os.time()

    print()
    printf("System information as of %s", os.date("%Y-%m-%dT%T%z", now))
    print()

    local w = setmetatable({prefix = "  "}, writer_mt)
    pcall(loadavg, w)
    pcall(meminfo, w)
    pcall(fsusage, w, "/")
    pcall(fsusage, w, "/home")
    pcall(uptime, w, now)
    pcall(temp, w)
    for _, line in ipairs(w) do print(line) end

    print()
end

motd()
