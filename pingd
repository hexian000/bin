#!/usr/bin/env python3

import os
import sys
import signal
import socket
import time
import icmplib
import numpy as np
import argparse
import logging

PID = os.getpid()
nohup = False


class InterruptedException(Exception):
    pass


def on_signal(signum, frame) -> None:
    if nohup and signum == signal.SIGHUP:
        return
    raise InterruptedException()


signal.signal(signal.SIGINT, on_signal)
signal.signal(signal.SIGTERM, on_signal)
signal.signal(signal.SIGHUP, on_signal)


class Statistics:
    def __init__(self):
        self.rtt_list = []
        self.sent = 0
        self.last = time.monotonic()


stat_data = Statistics()


def ping(sock, sequence, address, size, timeout):
    request = icmplib.ICMPRequest(
        destination=address,
        id=PID,
        payload_size=size,
        sequence=sequence)
    sock.send(request)
    stat_data.sent = stat_data.sent + 1
    reply = sock.receive(request, timeout)
    reply.raise_for_status()
    stat_data.rtt_list.append(reply.time - request.time)
    rtt = (reply.time - request.time) * 1000
    logging.debug("%s",
                  f'{reply.bytes_received} bytes from '
                  f'{reply.source}: '
                  f'icmp_seq={sequence} '
                  f'time={round(rtt, 3)} ms')


def stats(force=False):
    global stat_data
    if not force:
        now = time.monotonic()
        if now - stat_data.last < args.stats:
            return
    sent = stat_data.sent
    received = len(stat_data.rtt_list)
    if sent > 0:
        logging.info("PING %d packets transmitted, %d received, %.1f%% packet loss",
                     sent, received, (sent-received)*1e+2/sent)
    if received > 0:
        a = np.array(stat_data.rtt_list)
        logging.info("RTT min=%.3fms avg=%.3fms 90%%=%.3fms 99%%=%.3fms max=%.3fms mdev=%.3fms",
                     np.min(a)*1e+3,
                     np.mean(a)*1e+3,
                     np.percentile(a, 90)*1e+3,
                     np.percentile(a, 99)*1e+3,
                     np.max(a)*1e+3,
                     np.std(a)*1e+3)
    stat_data = Statistics()


socket_family = {
    socket.AF_INET: icmplib.ICMPv4Socket,
    socket.AF_INET6: icmplib.ICMPv6Socket
}


def resolve(host, family=None):
    if family is not None:
        for info in socket.getaddrinfo(host=host, family=family):
            if info[1] == socket.SOCK_RAW and info[0] == family:
                return info[0], info[4][0]
    else:
        for info in socket.getaddrinfo(host):
            if info[1] == socket.SOCK_RAW and info[0] in socket_family:
                return info[0], info[4][0]
    raise Exception("can't resolve host name: %s" % host)


def is_root():
    return os.geteuid() == 0


def create_socket(family):
    return socket_family.get(family)(privileged=is_root())


def try_ping(host_str, sock, sequence, address, size, timeout):
    try:
        ping(sock, sequence, address, size, timeout)
    except icmplib.ICMPError as err:
        logging.debug("PING %s: %s", host_str, err)
    except icmplib.TimeoutExceeded:
        logging.debug("PING %s: icmp_seq=%s timeout",
                      host_str, sequence)
    stats()


def main(args):
    sequence = 0
    family = None
    if args.ipv6:
        family = socket.AF_INET6
    elif args.ipv4:
        family = socket.AF_INET
    try:
        family, address = resolve(args.host, family)
        sock = create_socket(family)
        host_str = args.host
        if args.host != address:
            host_str = "%s (%s)" % (args.host, address)
        logging.info("PING %s: %d data bytes", host_str, args.size)
        while True:
            sequence = sequence + 1
            if sequence > 65535:
                sequence = 1
            try_ping(host_str, sock, sequence,
                     address, args.size, args. timeout)
            time.sleep(args.interval)
    except KeyboardInterrupt:
        pass
    except InterruptedException:
        pass
    except Exception as err:
        logging.error("pingd: %s", err)
    stats(True)


def fork_daemon():
    global nohup
    nohup = True
    pid = os.fork()
    if pid == 0:
        return
    print("PID %d" % pid)
    sys.exit()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="ICMP ping test daemon")
    parser.add_argument(
        "-4", "--ipv4", help="use ipv4", default=True, action='store_true')
    parser.add_argument(
        "-6", "--ipv6", help="use ipv6", action='store_true')
    parser.add_argument(
        "-i", "--interval", help="interval in seconds", type=int, default=1)
    parser.add_argument(
        "-W", "--timeout", help="request timeout in seconds", type=int, default=4)
    parser.add_argument(
        "-s", "--size", help="payload size", type=int, default=56)
    parser.add_argument(
        "-n", "--stats", help="stats time span in seconds", type=int, default=7200)
    parser.add_argument(
        "-l", "--log", help="log filename", type=str)
    parser.add_argument(
        "-v", "--verbose", help="write verbose log to file", action='store_true')
    parser.add_argument("host", help="host to ping", type=str)
    args = parser.parse_args()

    if args.log is None:
        # debug mode
        log_stream = sys.stdout
        log_level = logging.DEBUG
    else:
        fork_daemon()
        log_stream = open(args.log, "w")
        log_level = logging.DEBUG if args.verbose else logging.INFO

    logging.basicConfig(
        stream=log_stream,
        level=log_level,
        format="%(asctime)s %(levelname)-8s %(message)s",
        datefmt="%FT%T%z"
    )
    main(args)
